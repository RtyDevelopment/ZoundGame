<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>w = 10;
h = 10;
gridsize = 10;
surfsize = 50;
wallperc = 0.2;

maze = maze_create(w, h);
surf = -1;
col1 = -1;
col2 = -1;
gridperc = 1-wallperc*2;
x = (irandom(w-1)+0.5)*gridsize;
y = (irandom(h-1)+0.5)*gridsize;
z = 0.65*gridsize;
direction = 0;
zdirection = 0;
name = global.name;
live = 1;

bumpsnd = false;

globalvar xto, yto, zto, xup, yup, zup, xx, yy, zz;
xx = x;
yy = y;
zz = z;

xto = 1;
yto = 0;
zto = 0;

xup = 0;
yup = 0;
zup = 1;

if (os_get_config()!="OEM") {
    d3d_start();
    d3d_set_hidden(true);
    d3d_set_lighting(false);
    d3d_set_culling(false);
    //d3d_set_fog(true,c_black,10,300);
    texture_set_interpolation(true);
} else {
    //viewstuff
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (os_get_config()!="OEM") {
    var sxx,syy,cx,cy;
    sxx = window_mouse_get_x();
    syy = window_mouse_get_y();
    cx = round(window_get_width()/2);
    cy = round(window_get_height()/2);
    direction = (direction-(sxx-cx)/10) mod 360;
    zdirection = max(-89,min(89,zdirection-(syy-cy)/10));
    window_mouse_set(cx,cy);
}

var xold, yold;
xold = x;
yold = y;

resetbump = true;

if (os_get_config()!="OEM") {
    if (keyboard_check(ord("W"))==true) {
        if (maze_move_self(maze, x, y, direction, 1/16*gridsize, 0, gridsize, 0.6, 0.15)!=0) {
            if (bumpsnd==false) {
            with (instance_create(x, y, obj_gameobject)) {
                type = 3;
                sndtype = 5;
                z = other.z;
            }
            bumpsnd = true;
            }
            resetbump = false;
        }
    }
    if (keyboard_check(ord("S"))==true) {
        if (maze_move_self(maze, x, y, direction+180, 1/16*gridsize, 0, gridsize, 0.6, 0.15)!=0) {
            if (bumpsnd==false) {
            with (instance_create(x, y, obj_gameobject)) {
                type = 3;
                sndtype = 5;
                z = other.z;
            }
            bumpsnd = true;
            }
            resetbump = false;
        }
    }
    if (keyboard_check(ord("A"))==true) {
        if (maze_move_self(maze, x, y, direction+90, 1/16*gridsize, 0, gridsize, 0.6, 0.15)!=0) {
            if (bumpsnd==false) {
            with (instance_create(x, y, obj_gameobject)) {
                type = 3;
                sndtype = 5;
                z = other.z;
            }
            bumpsnd = true;
            }
            resetbump = false;
        }
    }
    if (keyboard_check(ord("D"))==true) {
        if (maze_move_self(maze, x, y, direction+270, 1/16*gridsize, 0, gridsize, 0.6, 0.15)!=0) {
            if (bumpsnd==false) {
            with (instance_create(x, y, obj_gameobject)) {
                type = 3;
                sndtype = 5;
                z = other.z;
            }
            bumpsnd = true;
            }
            resetbump = false;
        }
    }
} else {
    if (keyboard_check_pressed(ord("W"))==true) {
        //if (string_char_at(ds_grid_get(maze, floor(x/gridsize), floor(y/gridsize)), (((360-direction)/90+1) mod 4)+1) == "1") {
        if (maze_move_self(maze, x, y, direction, gridsize, 0, gridsize, 0.6, 0.15)!=0) {
            if (bumpsnd==false) {
            with (instance_create(x, y, obj_gameobject)) {
                type = 3;
                sndtype = 5;
                z = other.z;
            }
            bumpsnd = true;
            }
            resetbump = false;
        }
        x = (floor(x/gridsize)+0.5)*gridsize;
        y = (floor(y/gridsize)+0.5)*gridsize;
        //}
    }
    if (keyboard_check_pressed(ord("A"))==true) direction += 90;
    if (keyboard_check_pressed(ord("D"))==true) direction -= 90;
    
    globalvar xto, yto;
    xto = cos(direction);
    yto = -sin(direction);
    xx = x;
    yy = y;
}

if (resetbump==true) bumpsnd = false;

globalvar xto, yto, zto, xup, yup, zup, xx, yy, zz;
var v_dist, v_dir;
v_dist = point_distance(xold, yold, x, y);
v_dir = point_direction(xold, yold, x, y);
audio_listener_position(x, y, z);
audio_listener_velocity(lengthdir_x(v_dist, v_dir), lengthdir_y(v_dist, v_dir), 0);
audio_listener_orientation(xx+xto,yy+yto,zz+zto,xup,yup,zup);

if (floor(xold/gridsize)!=floor(x/gridsize) || floor(yold/gridsize)!=floor(y/gridsize)) {
    with (instance_create(x, y, obj_gameobject)) {
        type = 3;
        sndtype = 4;
        z = other.z;
    }
}

if (keyboard_check_pressed(vk_space)==true) {
    with (instance_create(x+lengthdir_x(0.2*gridsize, direction), y+lengthdir_y(0.2*gridsize, direction), obj_gameobject)) {
        type = 0;
        direction = other.direction;
        zdirection = other.zdirection;
    }
}

if (mouse_check_button_pressed(mb_left)==true) {
    with (instance_create(x+lengthdir_x(0.2*gridsize, direction), y+lengthdir_y(0.2*gridsize, direction), obj_gameobject)) {
        type = 1;
        direction = other.direction;
        zdirection = other.zdirection;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>globalvar scrwidth;
draw_set_alpha(1);
draw_set_color(c_green);
var cx = scrwidth-50;
var cy = 50;
draw_circle(cx, cy, 50, 1);
draw_triangle(cx+lengthdir_x(10, direction+90), cy+lengthdir_y(10, direction+90), cx+lengthdir_x(10, direction-90), cy+lengthdir_y(10, direction-90), cx+lengthdir_x(50, direction), cy+lengthdir_y(50, direction), 0);
draw_triangle(cx+lengthdir_x(10, direction+90), cy+lengthdir_y(10, direction+90), cx+lengthdir_x(10, direction-90), cy+lengthdir_y(10, direction-90), cx+lengthdir_x(30, direction+180), cy+lengthdir_y(30, direction+180), 0);

livelist = ds_list_create();
//namelist = ds_list_create();

ds_list_add(livelist, live);
//ds_list_add(namelist, name);

with (obj_gameobject) {
    if (type==4) {
        ds_list_add(other.livelist, live);
        //ds_list_add(other.namelist, name);
    }
}

for (var i=0; i&lt;ds_list_size(livelist); i++) {
    var life, name;
    life = ds_list_find_value(livelist, i)*125;
    //name = ds_list_find_value(namelist, i);
    
    draw_set_color(c_green);
    draw_rectangle(5, 5+i*25, 5+life, (i+1)*25, 0);
    draw_set_color(c_red);
    draw_rectangle(5+life, 5+i*25, 130, (i+1)*25, 0);
    draw_set_color(c_black);
    draw_rectangle(5, 5+i*25, 130, (i+1)*25, 1);
    draw_set_color(c_white);
    draw_set_font(fnt_default);
    draw_set_valign(fa_middle);
    draw_set_halign(fa_left);
    //draw_text(140, 15+i*25, name);
}
ds_list_destroy(livelist);
//ds_list_destroy(namelist);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_color(c_white);
draw_set_alpha(1);
d3d_end();
if (surface_exists(surf)==false) {
    surf = surface_create(w*surfsize, h*surfsize);
    surface_set_target(surf);
    draw_set_color(make_color_rgb(0, 120, 255));
    draw_rectangle(0, 0, w*surfsize, h*surfsize, 0);
    maze_draw_map(maze,0,0,w*surfsize,h*surfsize,gridperc,c_white,3,c_white,3);
    /*draw_set_blend_mode_ext(bm_src_alpha, bm_one);
    draw_circle_color(h*surfsize/2, h*surfsize/2, h*surfsize*0.7, c_dkgray, c_black, 0);
    draw_set_blend_mode(bm_normal);*/
    surface_reset_target();
}
if (surface_exists(col1)==false) {
    col1 = surface_create(1, 1);
    surface_set_target(col1);
    draw_set_alpha(1);
    draw_point_color(0, 0, c_aqua);
    surface_reset_target();
}
if (surface_exists(col2)==false) {
    col2 = surface_create(1, 1);
    surface_set_target(col2);
    draw_set_alpha(1);
    draw_point_color(0, 0, c_black);
    surface_reset_target();
}
draw_set_alpha(1);
draw_set_color(c_black);
draw_rectangle(0, 0, view_wview[view_current], view_hview[view_current], 0);

if (os_get_config()!="OEM") {
    d3d_start();
    d3d_set_projection_euler(x,y,z,direction,zdirection,0,0);
    d3d_draw_floor(0,0,-0.1,w*gridsize,h*gridsize,-0.1,-1,1,1);
    d3d_draw_floor(0,0,gridsize,w*gridsize,h*gridsize,gridsize,-1,1,1);
    draw_set_color(c_white);
    maze_draw_d3d(maze,0,0,0,w*gridsize,h*gridsize,gridsize,surface_get_texture(col2), surface_get_texture(col2), gridperc);
    
    d3d_set_hidden(false);
    d3d_transform_set_identity()
    //d3d_set_lighting(false)
    d3d_transform_add_rotation_x((0-zdirection)/2+25);
    d3d_transform_add_rotation_z(270+direction);
    
    var scale = 1/(power(2, gridsize*0.7));
    d3d_transform_add_scaling(scale, scale, scale);
    d3d_transform_add_translation(x+lengthdir_x(0.5*gridsize,direction), y+lengthdir_y(0.5*gridsize,direction), 0.25*gridsize);
    draw_surface(surf, 0-surface_get_width(surf)/2, 0-surface_get_height(surf)/2);
    /*draw_set_color(c_red);
    draw_circle(x/(w*gridsize)*(w*surfsize)-(w*surfsize)/2, y/(h*gridsize)*(h*surfsize)-(h*surfsize)/2, 0.1*surfsize, 0);
    xlist = ds_list_create();
    ylist = ds_list_create();
    with (obj_gameobject) {
        ds_list_add(other.xlist, x);
        ds_list_add(other.ylist, y);
    }
    draw_set_color(c_white);
    for (var i=0; i&lt;ds_list_size(xlist); i++) {
        draw_circle(ds_list_find_value(xlist, i)/(w*gridsize)*(w*surfsize)-(w*surfsize)/2, ds_list_find_value(ylist, i)/(h*gridsize)*(h*surfsize)-(h*surfsize)/2, 0.1*surfsize, 0);
    }
    ds_list_destroy(xlist);
    ds_list_destroy(ylist);*/
    
    //d3d_set_lighting(true)
    d3d_transform_set_identity();
    d3d_set_hidden(true);
} else {
    draw_surface(surf, 0, 0);
    /*draw_set_color(c_red);
    draw_circle(x/(w*gridsize)*(w*surfsize), y/(h*gridsize)*(h*surfsize), 0.1*surfsize, 0);
    draw_line(x/(w*gridsize)*(w*surfsize), y/(h*gridsize)*(h*surfsize), x/(w*gridsize)*(w*surfsize)+lengthdir_x(1/6*surfsize, direction), y/(h*gridsize)*(h*surfsize)+lengthdir_y(1/6*surfsize, direction));
    xlist = ds_list_create();
    ylist = ds_list_create();
    with (obj_gameobject) {
        ds_list_add(other.xlist, x);
        ds_list_add(other.ylist, y);
    }
    draw_set_color(c_white);
    for (var i=0; i&lt;ds_list_size(xlist); i++) {
        draw_circle(ds_list_find_value(xlist, i)/(w*gridsize)*(w*surfsize), ds_list_find_value(ylist, i)/(h*gridsize)*(h*surfsize), 0.1*surfsize, 0);
    }
    ds_list_destroy(xlist);
    ds_list_destroy(ylist);*/
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="10" enumb="38">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>maze = maze_create(w, h);
surface_free(surf);
x = (irandom(w-1)+0.5)*gridsize;
y = (irandom(h-1)+0.5)*gridsize;
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
