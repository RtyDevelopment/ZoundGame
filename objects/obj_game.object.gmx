<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>w = 10;
h = 10;
d3dsize = 10;
maze = create_maze(w, h);
surf = -1;
col1 = -1;
col2 = -1;

x = d3dsize/2;
y = d3dsize/2;

direction = 0;
zdirection = 0;

d3d_start();
d3d_set_hidden(true);
d3d_set_lighting(false);
d3d_set_culling(false);
//d3d_set_fog(true,c_black,10,300);
texture_set_interpolation(true);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var xx,yy,cx,cy;
xx = window_mouse_get_x();
yy = window_mouse_get_y();
cx = round(window_get_width()/2);
cy = round(window_get_height()/2);
direction = (direction-(xx-cx)/10) mod 360;
zdirection = max(-89,min(89,zdirection-(yy-cy)/10));
window_mouse_set(cx,cy);

if (keyboard_check(vk_alt)==true &amp;&amp; keyboard_check(vk_f4)==true || keyboard_check(vk_escape)) game_end();

if (keyboard_check(ord("W"))==true) {
    x += lengthdir_x(0.3, direction);
    y += lengthdir_y(0.3, direction);
}

if (keyboard_check(ord("S"))==true) {
    x += lengthdir_x(0.3, direction+180);
    y += lengthdir_y(0.3, direction+180);
}
if (keyboard_check(ord("A"))==true) {
    x += lengthdir_x(0.3, direction+90);
    y += lengthdir_y(0.3, direction+90);
}
if (keyboard_check(ord("D"))==true) {
    x += lengthdir_x(0.3, direction+270);
    y += lengthdir_y(0.3, direction+270);
}

direction = direction mod 360;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_set_color(c_black);
if (surface_exists(surf)==false) {
    d3d_end();
    surf = surface_create(w*25, h*25);
    surface_set_target(surf);
    draw_set_color(c_navy);
    draw_rectangle(0, 0, w*25, h*25, 0);
    maze_draw_map(maze,0,0,w*25,h*25,0.6,c_white,3,c_white,3);
    draw_set_blend_mode_ext(bm_src_alpha, bm_one);
    draw_circle_color(h*25/2, h*25/2, h*25*0.7, c_dkgray, c_black, 0);
    draw_set_blend_mode(bm_normal);
    surface_reset_target();
    d3d_start();
}
if (surface_exists(col1)==false) {
    d3d_end();
    col1 = surface_create(1, 1);
    surface_set_target(col1);
    draw_point_color(0, 0, c_aqua);
    surface_reset_target();
    d3d_start();
}
if (surface_exists(col2)==false) {
    d3d_end();
    col2 = surface_create(1, 1);
    surface_set_target(col2);
    draw_point_color(0, 0, c_black);
    surface_reset_target();
    d3d_start();
}

d3d_set_projection_euler(x,y,0.65*d3dsize,direction,zdirection,0,0);
draw_set_alpha(1);
draw_set_color(c_black);
d3d_draw_floor(0,0,0,w*d3dsize,h*d3dsize,0,-1,1,1);
draw_set_color(c_white);
maze_draw_d3d(maze,0,0,0,w*d3dsize,h*d3dsize,d3dsize,surface_get_texture(col1), surface_get_texture(col2), 0.6);

d3d_transform_set_identity()
//d3d_set_lighting(false)
d3d_transform_add_rotation_x((0-zdirection)/2+25);
d3d_transform_add_rotation_z(270+direction);
var scale = 1/(power(2, d3dsize*0.6));
d3d_transform_add_scaling(scale, scale, scale);
d3d_transform_add_translation(x+lengthdir_x(0.5*d3dsize,direction), y+lengthdir_y(0.5*d3dsize,direction), 0.25*d3dsize);
draw_surface(surf, 0-surface_get_width(surf)/2, 0-surface_get_height(surf)/2);
draw_set_color(c_red);
draw_circle(x/(w*d3dsize)*250-125, y/(h*d3dsize)*250-125, 3, 0);
//d3d_set_lighting(true)
d3d_transform_set_identity();
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
